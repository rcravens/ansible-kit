---
- hosts: localhost
  connection: local
  gather_facts: false
  vars_files:
    - ../../../../swarm_settings.yml

  tasks:
    - debug: var=resource_prefix
    - debug: var=aws_region

    # VPC
    - name: Create VPC
      amazon.aws.ec2_vpc_net:
        name: "{{vpc.name}}"
        cidr_block: "{{vpc.cidr}}"
        region: "{{vpc.region}}"
        tags:
          Name: "{{vpc.name}}"
        state: present
      register: my_vpc

#    - debug: var=my_vpc
    # VPC subnets
    - name: Create VPC subnets
      amazon.aws.ec2_vpc_subnet:
        state: present
        cidr: "{{item.cidr}}"
        region: "{{vpc.region}}"
        az: "{{item.az}}"
        vpc_id: "{{ my_vpc.vpc.id }}"
        tags:
          Name: "{{item.name}}"
      register: my_subnets
      with_items:
        - "{{vpc.subnets.public}}"
        - "{{vpc.subnets.private}}"

#    - debug: var=my_subnets

    - name: Create subnet lookup data
      set_fact:
        my_subnet_lut: "{{ my_subnet_lut|default({}) | combine( {item.subnet.tags.Name: item.subnet.id} ) }}"
      with_items: "{{my_subnets.results}}"

#    - debug: var=my_subnet_lut
#    - debug: var=my_subnet_lut["{{resource_prefix}}-vpc-{{vpc.subnets.public[0].name}}"]
#    - name: Get first public subnet id
#      set_fact:
#        my_public_subnet_1: "{{ my_subnet_lut[resource_prefix ~ '-vpc-' ~ vpc.subnets.public[0].name] }}"

#    - debug: var=my_public_subnet_1


    # Internet gateway
    - name: Create internet gateway
      amazon.aws.ec2_vpc_igw:
        vpc_id: "{{ my_vpc.vpc.id }}"
        state: present
        tags:
          Name: "{{vpc.igw.name}}"
      register: my_igw

    # NAT gateway
    - name: Create nat gateway
      amazon.aws.ec2_vpc_nat_gateway:
        state: present
        subnet_id: "{{ my_subnet_lut[vpc.subnets.public[0].name] }}"
        if_exist_do_not_create: yes
        release_eip: true
        region: "{{vpc.region}}"
        tags:
          Name: "{{vpc.nat.name}}"
      register: my_nat

    # Create route table for IGW and two public subnets
    - name: Create internet gateway route table
      amazon.aws.ec2_vpc_route_table:
        vpc_id: "{{ my_vpc.vpc.id }}"
        region: "{{vpc.region}}"
        tags:
          Name: "{{vpc.igw.route_table.name}}"
        subnets:
          - "{{ my_subnet_lut[vpc.subnets.public[0].name] }}"
          - "{{ my_subnet_lut[vpc.subnets.public[1].name] }}"
        routes:
          - dest: 0.0.0.0/0
            gateway_id: "{{ my_igw.gateway_id }}"
      register: my_public_rt

    # Create route table for NAT and two private subnets
    - name: Create NAT gateway route table
      amazon.aws.ec2_vpc_route_table:
        vpc_id: "{{ my_vpc.vpc.id }}"
        region: "{{vpc.region}}"
        tags:
          Name: "{{vpc.nat.route_table.name}}"
        subnets:
          - "{{ my_subnet_lut[vpc.subnets.private[0].name] }}"
          - "{{ my_subnet_lut[vpc.subnets.private[1].name] }}"
        routes:
          - dest: 0.0.0.0/0
            gateway_id: "{{ my_nat.nat_gateway_id }}"
      register: my_private_rt

    # Create VPC security groups
    - name: Create VPC security groups
      amazon.aws.ec2_security_group:
        name: "{{item.name}}"
        description: "{{item.description}}"
        vpc_id: "{{ my_vpc.vpc.id }}"
        region: "{{vpc.region}}"
        tags:
          Name: "{{item.name}}"
        rules: "{{item.rules}}"
      with_items:
        - "{{vpc.security_groups.web}}"
        - "{{vpc.security_groups.ssh}}"
        - "{{vpc.security_groups.swarm}}"
      register: my_sgs

#    - debug: var=my_sgs

#    - name: Obtain all information for a single ACM certificate
#      aws_acm_info:
#        domain_name: "{{domain}}"
#      register: my_cert
#
#    - debug: var=my_cert
#    - debug: var=my_cert.certificates[0].certificate_arn

    # Create an ALB target group
    - name: Create target groups with a default health check
      community.aws.elb_target_group:
        name: "{{item.name}}"
        protocol: "{{item.protocol}}"
        port: "{{item.port}}"
        vpc_id: "{{ my_vpc.vpc.id }}"
        state: present
      with_items: "{{vpc.alb.target_groups}}"

    # Create application load balancer
    - name: Create ALB and add HTTPS listeners
      amazon.aws.elb_application_lb:
        name: "{{vpc.alb.name}}"
        subnets:
          - "{{ my_subnet_lut[vpc.subnets.public[0].name] }}"
          - "{{ my_subnet_lut[vpc.subnets.public[1].name] }}"
        security_groups:
          - "{{vpc.security_groups.web.name}}"
        region: "{{vpc.region}}"
        listeners:
          - Protocol: "{{item.protocol}}"
            Port: "{{item.port}}"
            SslPolicy: "{{item.ssl_policy}}"
            Certificates: "{{item.certificates}}"
            DefaultActions:
              - Type: forward
                TargetGroupName: "{{item.name}}"
        state: present
        purge_listeners: no
      with_items: "{{vpc.alb.target_groups}}"
      when:
        - item.port == 443
      register: my_alb

    - name: Update ALB to include HTTP listeners
      amazon.aws.elb_application_lb:
        name: "{{vpc.alb.name}}"
        subnets:
          - "{{ my_subnet_lut[vpc.subnets.public[0].name] }}"
          - "{{ my_subnet_lut[vpc.subnets.public[1].name] }}"
        security_groups:
          - "{{vpc.security_groups.web.name}}"
        region: "{{vpc.region}}"
        listeners:
          - Protocol: "{{item.protocol}}"
            Port: "{{item.port}}"
            DefaultActions:
              - Type: forward
                TargetGroupName: "{{item.name}}"
        state: present
        purge_listeners: no
      with_items: "{{vpc.alb.target_groups}}"
      when:
        - item.port != 443
      register: my_alb

#    - debug: var=my_alb

    # Create DNS records for the ALB
    - name: Create DNS records for the new ALB
      amazon.aws.route53:
        state: present
        zone: "{{domain}}"
        record: "{{sub_domain}}"
        type: CNAME
        ttl: 300
        value: "{{my_alb.results[0].dns_name}}"
        overwrite: yes


    # Create key pair to create EC2 instances
    - name: Create a key pair
      amazon.aws.ec2_key:
        name: "{{ vpc.ec2.key_pair_name }}"
        force: false  # If it exists, do not overwrite
      no_log: true
      register: my_key_pair
      ignore_errors: yes # Do not stop the playbook if this fails

    - debug: var=my_key_pair

    - name: "Saving private key to {{vpc.ec2.key_pair_local_directory}}"
      ansible.builtin.copy:
        dest: "{{ vpc.ec2.key_pair_local_directory }}{{ vpc.ec2.key_pair_name}}.pem"
        content: "{{ my_key_pair['key']['private_key'] }}"
        mode: '0600'
        force: false
      register: my_key_pair_saved
      when: my_key_pair.changed == true
      ignore_errors: yes

    - name: "Ensure private key exists locally {{ vpc.ec2.key_pair_local_directory }}{{ vpc.ec2.key_pair_name}}.pem."
      ansible.builtin.stat:
        path: "{{ vpc.ec2.key_pair_local_directory }}{{ vpc.ec2.key_pair_name}}.pem"
      register: my_key_pair_file_exists

    - name: "Deleting {{ vpc.ec2.key_pair_name }} since it couldn't be saved."
      amazon.aws.ec2_key:
        name: "{{ vpc.ec2.key_pair_name }}"
        state: absent
      when: not my_key_pair_file_exists.stat.exists or (my_key_pair.changed == true and my_key_pair_saved.changed == false)
      register: delete_key_pair

    - name: "Failed to create key pair"
      ansible.builtin.fail:
        msg: >
          The file {{ vpc.ec2.key_pair_local_directory }}{{ vpc.ec2.key_pair_name}}.pem already exists but the
          key pair {{ vpc.ec2.key_pair_name }} doesn't exists on AWS.
          Change either the aws_key_pair_name or the aws_key_pair_local_path
      when: delete_key_pair.changed == true

    # Create jump box / bastion server
    - name: Provision jump box / bastion server
      amazon.aws.ec2_instance:
        key_name: "{{ vpc.ec2.key_pair_name }}"
        image_id: "{{ vpc.ec2.ami }}"
        instance_type: "{{ vpc.ec2.default_instance_type }}"
        vpc_subnet_id: "{{ my_subnet_lut[vpc.subnets.public[0].name] }}"
        #iam_instance_profile: "{{ aws_iam_role_name }}"
        network:
          assign_public_ip: yes
        security_groups: "{{ vpc.ec2.jump_box.security_groups }}"
        tags: "{{ vpc.ec2.jump_box.tags }}"
        wait: yes
        exact_count: 1
      register: jump_boxes

    # Create EC2 instances for Docker Swarm manager
    - name: Provision Docker Swarm manager EC2 instances.
      amazon.aws.ec2_instance:
        key_name: "{{ vpc.ec2.key_pair_name }}"
        image_id: "{{ vpc.ec2.ami }}"
        instance_type: "{{ vpc.ec2.default_instance_type }}"
        vpc_subnet_id: "{{ my_subnet_lut[vpc.subnets.private[0].name] }}"
        #iam_instance_profile: "{{ aws_iam_role_name }}"
        network:
          assign_public_ip: no
        security_groups: "{{ vpc.ec2.swarm_nodes.security_groups }}"
        tags: "{{ vpc.ec2.swarm_nodes.managers.tags }}"
        wait: yes
        exact_count: "{{vpc.ec2.swarm_nodes.managers.count}}"
      register: swarm_managers

    - name: Provision Docker Swarm workers EC2 instances.
      amazon.aws.ec2_instance:
        key_name: "{{ vpc.ec2.key_pair_name }}"
        image_id: "{{ vpc.ec2.ami }}"
        instance_type: "{{ vpc.ec2.default_instance_type }}"
        vpc_subnet_id: "{{ my_subnet_lut[vpc.subnets.private[0].name] }}"
        #iam_instance_profile: "{{ aws_iam_role_name }}"
        network:
          assign_public_ip: no
        security_groups: "{{ vpc.ec2.swarm_nodes.security_groups }}"
        tags: "{{ vpc.ec2.swarm_nodes.workers.tags }}"
        wait: yes
        exact_count: "{{ vpc.ec2.swarm_nodes.workers.count }}"
      register: swarm_workers

#    - debug: var=jump_boxes
#    - debug: var=swarm_managers
#    - debug: var=swarm_workers

    - name: Register targets with ALB target group
      community.aws.elb_target:
        target_group_name: "{{item[1].name}}"
        target_id: "{{item[0].instance_id}}"
        state: present
      loop: "{{ (swarm_managers.instances + swarm_workers.instances) | product(vpc.alb.target_groups) | list }}"

    - name: TEST
      debug: var=jump_boxes.instances[0].public_ip_address

    - name: Dynamically create inventory file using template.
      template:
        src: ../../../../inventories/swarm_inventory.j2
        dest: ../../../../server/inventory.yml

#
#
#    - name: Create target groups with a default health check
#      community.aws.elb_target_group:
#        name: "{{resource_prefix}}-{{item.name}}"
#        protocol: "{{item.protocol}}"
#        port: "{{item.port}}"
#        vpc_id: "{{ my_vpc.vpc.id }}"
#        state: present
#      with_items: "{{vpc.alb.target_groups}}"